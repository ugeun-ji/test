// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DSREGISTER_PACKET_CERTIFY_H_
#define FLATBUFFERS_GENERATED_DSREGISTER_PACKET_CERTIFY_H_

#include "flatbuffers/flatbuffers.h"

#include "daregister_generated.h"

namespace Packet {
namespace Certify {

struct DSChannel;

struct DSRegister;

struct DSChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CNAME = 4,
    VT_PORT = 6
  };
  const flatbuffers::String *cname() const {
    return GetPointer<const flatbuffers::String *>(VT_CNAME);
  }
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CNAME) &&
           verifier.VerifyString(cname()) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           verifier.EndTable();
  }
};

struct DSChannelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cname(flatbuffers::Offset<flatbuffers::String> cname) {
    fbb_.AddOffset(DSChannel::VT_CNAME, cname);
  }
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(DSChannel::VT_PORT, port, 0);
  }
  explicit DSChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DSChannelBuilder &operator=(const DSChannelBuilder &);
  flatbuffers::Offset<DSChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DSChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<DSChannel> CreateDSChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> cname = 0,
    uint32_t port = 0) {
  DSChannelBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_cname(cname);
  return builder_.Finish();
}

inline flatbuffers::Offset<DSChannel> CreateDSChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *cname = nullptr,
    uint32_t port = 0) {
  return Packet::Certify::CreateDSChannel(
      _fbb,
      cname ? _fbb.CreateString(cname) : 0,
      port);
}

struct DSRegister FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOKEN = 4,
    VT_CHANNELLIST = 6,
    VT_TYPE = 8
  };
  const flatbuffers::String *token() const {
    return GetPointer<const flatbuffers::String *>(VT_TOKEN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DSChannel>> *channelList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSChannel>> *>(VT_CHANNELLIST);
  }
  DSType type() const {
    return static_cast<DSType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.VerifyString(token()) &&
           VerifyOffset(verifier, VT_CHANNELLIST) &&
           verifier.VerifyVector(channelList()) &&
           verifier.VerifyVectorOfTables(channelList()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct DSRegisterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_token(flatbuffers::Offset<flatbuffers::String> token) {
    fbb_.AddOffset(DSRegister::VT_TOKEN, token);
  }
  void add_channelList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSChannel>>> channelList) {
    fbb_.AddOffset(DSRegister::VT_CHANNELLIST, channelList);
  }
  void add_type(DSType type) {
    fbb_.AddElement<uint8_t>(DSRegister::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit DSRegisterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DSRegisterBuilder &operator=(const DSRegisterBuilder &);
  flatbuffers::Offset<DSRegister> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DSRegister>(end);
    return o;
  }
};

inline flatbuffers::Offset<DSRegister> CreateDSRegister(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> token = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSChannel>>> channelList = 0,
    DSType type = DSType_Field) {
  DSRegisterBuilder builder_(_fbb);
  builder_.add_channelList(channelList);
  builder_.add_token(token);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DSRegister> CreateDSRegisterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *token = nullptr,
    const std::vector<flatbuffers::Offset<DSChannel>> *channelList = nullptr,
    DSType type = DSType_Field) {
  return Packet::Certify::CreateDSRegister(
      _fbb,
      token ? _fbb.CreateString(token) : 0,
      channelList ? _fbb.CreateVector<flatbuffers::Offset<DSChannel>>(*channelList) : 0,
      type);
}

inline const Packet::Certify::DSRegister *GetDSRegister(const void *buf) {
  return flatbuffers::GetRoot<Packet::Certify::DSRegister>(buf);
}

inline const Packet::Certify::DSRegister *GetSizePrefixedDSRegister(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Packet::Certify::DSRegister>(buf);
}

inline bool VerifyDSRegisterBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Packet::Certify::DSRegister>(nullptr);
}

inline bool VerifySizePrefixedDSRegisterBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Packet::Certify::DSRegister>(nullptr);
}

inline void FinishDSRegisterBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Packet::Certify::DSRegister> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDSRegisterBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Packet::Certify::DSRegister> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Certify
}  // namespace Packet

#endif  // FLATBUFFERS_GENERATED_DSREGISTER_PACKET_CERTIFY_H_
