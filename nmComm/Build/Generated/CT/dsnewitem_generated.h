// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DSNEWITEM_PACKET_CHARACTER_H_
#define FLATBUFFERS_GENERATED_DSNEWITEM_PACKET_CHARACTER_H_

#include "flatbuffers/flatbuffers.h"

namespace Packet {
namespace Character {

struct NewEquip;

struct NewMaterial;

struct DSNewItem;

enum TakenItem {
  TakenItem_NONE = 0,
  TakenItem_NewEquip = 1,
  TakenItem_NewMaterial = 2,
  TakenItem_MIN = TakenItem_NONE,
  TakenItem_MAX = TakenItem_NewMaterial
};

inline const TakenItem (&EnumValuesTakenItem())[3] {
  static const TakenItem values[] = {
    TakenItem_NONE,
    TakenItem_NewEquip,
    TakenItem_NewMaterial
  };
  return values;
}

inline const char * const *EnumNamesTakenItem() {
  static const char * const names[] = {
    "NONE",
    "NewEquip",
    "NewMaterial",
    nullptr
  };
  return names;
}

inline const char *EnumNameTakenItem(TakenItem e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTakenItem()[index];
}

template<typename T> struct TakenItemTraits {
  static const TakenItem enum_value = TakenItem_NONE;
};

template<> struct TakenItemTraits<NewEquip> {
  static const TakenItem enum_value = TakenItem_NewEquip;
};

template<> struct TakenItemTraits<NewMaterial> {
  static const TakenItem enum_value = TakenItem_NewMaterial;
};

bool VerifyTakenItem(flatbuffers::Verifier &verifier, const void *obj, TakenItem type);
bool VerifyTakenItemVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) NewEquip FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t type_;
  int8_t padding0__;
  int16_t tierlv_;

 public:
  NewEquip() {
    memset(this, 0, sizeof(NewEquip));
  }
  NewEquip(int8_t _type, int16_t _tierlv)
      : type_(flatbuffers::EndianScalar(_type)),
        padding0__(0),
        tierlv_(flatbuffers::EndianScalar(_tierlv)) {
    (void)padding0__;
  }
  int8_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  int16_t tierlv() const {
    return flatbuffers::EndianScalar(tierlv_);
  }
};
FLATBUFFERS_STRUCT_END(NewEquip, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) NewMaterial FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t cnt_;

 public:
  NewMaterial() {
    memset(this, 0, sizeof(NewMaterial));
  }
  NewMaterial(int32_t _cnt)
      : cnt_(flatbuffers::EndianScalar(_cnt)) {
  }
  int32_t cnt() const {
    return flatbuffers::EndianScalar(cnt_);
  }
};
FLATBUFFERS_STRUCT_END(NewMaterial, 4);

struct DSNewItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHARSID = 4,
    VT_ITEMID = 6,
    VT_ITEM_TYPE = 8,
    VT_ITEM = 10
  };
  int32_t charsid() const {
    return GetField<int32_t>(VT_CHARSID, 0);
  }
  int32_t itemid() const {
    return GetField<int32_t>(VT_ITEMID, 0);
  }
  TakenItem item_type() const {
    return static_cast<TakenItem>(GetField<uint8_t>(VT_ITEM_TYPE, 0));
  }
  const void *item() const {
    return GetPointer<const void *>(VT_ITEM);
  }
  template<typename T> const T *item_as() const;
  const NewEquip *item_as_NewEquip() const {
    return item_type() == TakenItem_NewEquip ? static_cast<const NewEquip *>(item()) : nullptr;
  }
  const NewMaterial *item_as_NewMaterial() const {
    return item_type() == TakenItem_NewMaterial ? static_cast<const NewMaterial *>(item()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARSID) &&
           VerifyField<int32_t>(verifier, VT_ITEMID) &&
           VerifyField<uint8_t>(verifier, VT_ITEM_TYPE) &&
           VerifyOffset(verifier, VT_ITEM) &&
           VerifyTakenItem(verifier, item(), item_type()) &&
           verifier.EndTable();
  }
};

template<> inline const NewEquip *DSNewItem::item_as<NewEquip>() const {
  return item_as_NewEquip();
}

template<> inline const NewMaterial *DSNewItem::item_as<NewMaterial>() const {
  return item_as_NewMaterial();
}

struct DSNewItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_charsid(int32_t charsid) {
    fbb_.AddElement<int32_t>(DSNewItem::VT_CHARSID, charsid, 0);
  }
  void add_itemid(int32_t itemid) {
    fbb_.AddElement<int32_t>(DSNewItem::VT_ITEMID, itemid, 0);
  }
  void add_item_type(TakenItem item_type) {
    fbb_.AddElement<uint8_t>(DSNewItem::VT_ITEM_TYPE, static_cast<uint8_t>(item_type), 0);
  }
  void add_item(flatbuffers::Offset<void> item) {
    fbb_.AddOffset(DSNewItem::VT_ITEM, item);
  }
  explicit DSNewItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DSNewItemBuilder &operator=(const DSNewItemBuilder &);
  flatbuffers::Offset<DSNewItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DSNewItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<DSNewItem> CreateDSNewItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t charsid = 0,
    int32_t itemid = 0,
    TakenItem item_type = TakenItem_NONE,
    flatbuffers::Offset<void> item = 0) {
  DSNewItemBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_itemid(itemid);
  builder_.add_charsid(charsid);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

inline bool VerifyTakenItem(flatbuffers::Verifier &verifier, const void *obj, TakenItem type) {
  switch (type) {
    case TakenItem_NONE: {
      return true;
    }
    case TakenItem_NewEquip: {
      return true;
    }
    case TakenItem_NewMaterial: {
      return true;
    }
    default: return false;
  }
}

inline bool VerifyTakenItemVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTakenItem(
        verifier,  values->Get(i), types->GetEnum<TakenItem>(i))) {
      return false;
    }
  }
  return true;
}

inline const Packet::Character::DSNewItem *GetDSNewItem(const void *buf) {
  return flatbuffers::GetRoot<Packet::Character::DSNewItem>(buf);
}

inline const Packet::Character::DSNewItem *GetSizePrefixedDSNewItem(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Packet::Character::DSNewItem>(buf);
}

inline bool VerifyDSNewItemBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Packet::Character::DSNewItem>(nullptr);
}

inline bool VerifySizePrefixedDSNewItemBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Packet::Character::DSNewItem>(nullptr);
}

inline void FinishDSNewItemBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Packet::Character::DSNewItem> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDSNewItemBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Packet::Character::DSNewItem> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Character
}  // namespace Packet

#endif  // FLATBUFFERS_GENERATED_DSNEWITEM_PACKET_CHARACTER_H_
