// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CTENTERCHARACTER_PACKET_CHARACTER_H_
#define FLATBUFFERS_GENERATED_CTENTERCHARACTER_PACKET_CHARACTER_H_

#include "flatbuffers/flatbuffers.h"

#include "daammo_generated.h"
#include "daequipinventory_generated.h"
#include "daequipitem_generated.h"
#include "damaterialinventory_generated.h"
#include "damaterialitem_generated.h"
#include "daquest_generated.h"
#include "daquestobjective_generated.h"

namespace Packet {
namespace Character {

struct CTEnterCharacter;

struct CTEnterCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SID = 4,
    VT_CHANNEL = 6,
    VT_NAME = 8,
    VT_GENDER = 10,
    VT_HAIR = 12,
    VT_CHECKPOINT = 14,
    VT_GOLD = 16,
    VT_EQINV = 18,
    VT_EQ = 20,
    VT_MINV = 22,
    VT_AMMO = 24,
    VT_LASTCOMPLETESCENARIO = 26,
    VT_PROGRESSSCENARIO = 28,
    VT_PROGRESSMISSION = 30,
    VT_CURRENTMISSIONUNLOCK = 32,
    VT_PARTYID = 34,
    VT_WAYPOINT = 36
  };
  int32_t sid() const {
    return GetField<int32_t>(VT_SID, 0);
  }
  int32_t channel() const {
    return GetField<int32_t>(VT_CHANNEL, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int8_t gender() const {
    return GetField<int8_t>(VT_GENDER, 0);
  }
  int8_t hair() const {
    return GetField<int8_t>(VT_HAIR, 0);
  }
  int32_t checkpoint() const {
    return GetField<int32_t>(VT_CHECKPOINT, 0);
  }
  uint64_t gold() const {
    return GetField<uint64_t>(VT_GOLD, 0);
  }
  const DAEquipInventory *eqinv() const {
    return GetPointer<const DAEquipInventory *>(VT_EQINV);
  }
  const flatbuffers::Vector<int64_t> *eq() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EQ);
  }
  const DAMaterialInventory *minv() const {
    return GetPointer<const DAMaterialInventory *>(VT_MINV);
  }
  const flatbuffers::Vector<const DAAmmo *> *ammo() const {
    return GetPointer<const flatbuffers::Vector<const DAAmmo *> *>(VT_AMMO);
  }
  const DAQuest *lastcompletescenario() const {
    return GetPointer<const DAQuest *>(VT_LASTCOMPLETESCENARIO);
  }
  const DAQuest *progressscenario() const {
    return GetPointer<const DAQuest *>(VT_PROGRESSSCENARIO);
  }
  const DAQuest *progressmission() const {
    return GetPointer<const DAQuest *>(VT_PROGRESSMISSION);
  }
  int32_t currentmissionunlock() const {
    return GetField<int32_t>(VT_CURRENTMISSIONUNLOCK, 0);
  }
  int32_t partyid() const {
    return GetField<int32_t>(VT_PARTYID, 0);
  }
  const flatbuffers::Vector<int32_t> *waypoint() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_WAYPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SID) &&
           VerifyField<int32_t>(verifier, VT_CHANNEL) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_GENDER) &&
           VerifyField<int8_t>(verifier, VT_HAIR) &&
           VerifyField<int32_t>(verifier, VT_CHECKPOINT) &&
           VerifyField<uint64_t>(verifier, VT_GOLD) &&
           VerifyOffset(verifier, VT_EQINV) &&
           verifier.VerifyTable(eqinv()) &&
           VerifyOffset(verifier, VT_EQ) &&
           verifier.VerifyVector(eq()) &&
           VerifyOffset(verifier, VT_MINV) &&
           verifier.VerifyTable(minv()) &&
           VerifyOffset(verifier, VT_AMMO) &&
           verifier.VerifyVector(ammo()) &&
           VerifyOffset(verifier, VT_LASTCOMPLETESCENARIO) &&
           verifier.VerifyTable(lastcompletescenario()) &&
           VerifyOffset(verifier, VT_PROGRESSSCENARIO) &&
           verifier.VerifyTable(progressscenario()) &&
           VerifyOffset(verifier, VT_PROGRESSMISSION) &&
           verifier.VerifyTable(progressmission()) &&
           VerifyField<int32_t>(verifier, VT_CURRENTMISSIONUNLOCK) &&
           VerifyField<int32_t>(verifier, VT_PARTYID) &&
           VerifyOffset(verifier, VT_WAYPOINT) &&
           verifier.VerifyVector(waypoint()) &&
           verifier.EndTable();
  }
};

struct CTEnterCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sid(int32_t sid) {
    fbb_.AddElement<int32_t>(CTEnterCharacter::VT_SID, sid, 0);
  }
  void add_channel(int32_t channel) {
    fbb_.AddElement<int32_t>(CTEnterCharacter::VT_CHANNEL, channel, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CTEnterCharacter::VT_NAME, name);
  }
  void add_gender(int8_t gender) {
    fbb_.AddElement<int8_t>(CTEnterCharacter::VT_GENDER, gender, 0);
  }
  void add_hair(int8_t hair) {
    fbb_.AddElement<int8_t>(CTEnterCharacter::VT_HAIR, hair, 0);
  }
  void add_checkpoint(int32_t checkpoint) {
    fbb_.AddElement<int32_t>(CTEnterCharacter::VT_CHECKPOINT, checkpoint, 0);
  }
  void add_gold(uint64_t gold) {
    fbb_.AddElement<uint64_t>(CTEnterCharacter::VT_GOLD, gold, 0);
  }
  void add_eqinv(flatbuffers::Offset<DAEquipInventory> eqinv) {
    fbb_.AddOffset(CTEnterCharacter::VT_EQINV, eqinv);
  }
  void add_eq(flatbuffers::Offset<flatbuffers::Vector<int64_t>> eq) {
    fbb_.AddOffset(CTEnterCharacter::VT_EQ, eq);
  }
  void add_minv(flatbuffers::Offset<DAMaterialInventory> minv) {
    fbb_.AddOffset(CTEnterCharacter::VT_MINV, minv);
  }
  void add_ammo(flatbuffers::Offset<flatbuffers::Vector<const DAAmmo *>> ammo) {
    fbb_.AddOffset(CTEnterCharacter::VT_AMMO, ammo);
  }
  void add_lastcompletescenario(flatbuffers::Offset<DAQuest> lastcompletescenario) {
    fbb_.AddOffset(CTEnterCharacter::VT_LASTCOMPLETESCENARIO, lastcompletescenario);
  }
  void add_progressscenario(flatbuffers::Offset<DAQuest> progressscenario) {
    fbb_.AddOffset(CTEnterCharacter::VT_PROGRESSSCENARIO, progressscenario);
  }
  void add_progressmission(flatbuffers::Offset<DAQuest> progressmission) {
    fbb_.AddOffset(CTEnterCharacter::VT_PROGRESSMISSION, progressmission);
  }
  void add_currentmissionunlock(int32_t currentmissionunlock) {
    fbb_.AddElement<int32_t>(CTEnterCharacter::VT_CURRENTMISSIONUNLOCK, currentmissionunlock, 0);
  }
  void add_partyid(int32_t partyid) {
    fbb_.AddElement<int32_t>(CTEnterCharacter::VT_PARTYID, partyid, 0);
  }
  void add_waypoint(flatbuffers::Offset<flatbuffers::Vector<int32_t>> waypoint) {
    fbb_.AddOffset(CTEnterCharacter::VT_WAYPOINT, waypoint);
  }
  explicit CTEnterCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CTEnterCharacterBuilder &operator=(const CTEnterCharacterBuilder &);
  flatbuffers::Offset<CTEnterCharacter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CTEnterCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<CTEnterCharacter> CreateCTEnterCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sid = 0,
    int32_t channel = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int8_t gender = 0,
    int8_t hair = 0,
    int32_t checkpoint = 0,
    uint64_t gold = 0,
    flatbuffers::Offset<DAEquipInventory> eqinv = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> eq = 0,
    flatbuffers::Offset<DAMaterialInventory> minv = 0,
    flatbuffers::Offset<flatbuffers::Vector<const DAAmmo *>> ammo = 0,
    flatbuffers::Offset<DAQuest> lastcompletescenario = 0,
    flatbuffers::Offset<DAQuest> progressscenario = 0,
    flatbuffers::Offset<DAQuest> progressmission = 0,
    int32_t currentmissionunlock = 0,
    int32_t partyid = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> waypoint = 0) {
  CTEnterCharacterBuilder builder_(_fbb);
  builder_.add_gold(gold);
  builder_.add_waypoint(waypoint);
  builder_.add_partyid(partyid);
  builder_.add_currentmissionunlock(currentmissionunlock);
  builder_.add_progressmission(progressmission);
  builder_.add_progressscenario(progressscenario);
  builder_.add_lastcompletescenario(lastcompletescenario);
  builder_.add_ammo(ammo);
  builder_.add_minv(minv);
  builder_.add_eq(eq);
  builder_.add_eqinv(eqinv);
  builder_.add_checkpoint(checkpoint);
  builder_.add_name(name);
  builder_.add_channel(channel);
  builder_.add_sid(sid);
  builder_.add_hair(hair);
  builder_.add_gender(gender);
  return builder_.Finish();
}

inline flatbuffers::Offset<CTEnterCharacter> CreateCTEnterCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t sid = 0,
    int32_t channel = 0,
    const char *name = nullptr,
    int8_t gender = 0,
    int8_t hair = 0,
    int32_t checkpoint = 0,
    uint64_t gold = 0,
    flatbuffers::Offset<DAEquipInventory> eqinv = 0,
    const std::vector<int64_t> *eq = nullptr,
    flatbuffers::Offset<DAMaterialInventory> minv = 0,
    const std::vector<DAAmmo> *ammo = nullptr,
    flatbuffers::Offset<DAQuest> lastcompletescenario = 0,
    flatbuffers::Offset<DAQuest> progressscenario = 0,
    flatbuffers::Offset<DAQuest> progressmission = 0,
    int32_t currentmissionunlock = 0,
    int32_t partyid = 0,
    const std::vector<int32_t> *waypoint = nullptr) {
  return Packet::Character::CreateCTEnterCharacter(
      _fbb,
      sid,
      channel,
      name ? _fbb.CreateString(name) : 0,
      gender,
      hair,
      checkpoint,
      gold,
      eqinv,
      eq ? _fbb.CreateVector<int64_t>(*eq) : 0,
      minv,
      ammo ? _fbb.CreateVectorOfStructs<DAAmmo>(*ammo) : 0,
      lastcompletescenario,
      progressscenario,
      progressmission,
      currentmissionunlock,
      partyid,
      waypoint ? _fbb.CreateVector<int32_t>(*waypoint) : 0);
}

inline const Packet::Character::CTEnterCharacter *GetCTEnterCharacter(const void *buf) {
  return flatbuffers::GetRoot<Packet::Character::CTEnterCharacter>(buf);
}

inline const Packet::Character::CTEnterCharacter *GetSizePrefixedCTEnterCharacter(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Packet::Character::CTEnterCharacter>(buf);
}

inline bool VerifyCTEnterCharacterBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Packet::Character::CTEnterCharacter>(nullptr);
}

inline bool VerifySizePrefixedCTEnterCharacterBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Packet::Character::CTEnterCharacter>(nullptr);
}

inline void FinishCTEnterCharacterBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Packet::Character::CTEnterCharacter> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCTEnterCharacterBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Packet::Character::CTEnterCharacter> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Character
}  // namespace Packet

#endif  // FLATBUFFERS_GENERATED_CTENTERCHARACTER_PACKET_CHARACTER_H_
